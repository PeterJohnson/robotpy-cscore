.. THIS FILE IS AUTOGENERATED, DO NOT MODIFY

Objects
=======


AxisCamera
----------

.. py:class:: AxisCamera(*args, **kwargs)
   :module: cscore

   Overloaded function.
   
   1. __init__(self: cscore.AxisCamera, name: llvm::StringRef, host: llvm::StringRef) -> None
   
   Create a source for a MJPEG-over-HTTP (IP) camera.
   
   :param name: Source name (arbitrary unique identifier)
   :param urls: Array of Camera URLs
   :param kind: Camera kind (e.g. kAxis)
   
   2. __init__(self: cscore.AxisCamera, name: llvm::StringRef, host: str) -> None
   
   Create a source for a MJPEG-over-HTTP (IP) camera.
   
   :param name: Source name (arbitrary unique identifier)
   :param urls: Array of Camera URLs
   :param kind: Camera kind (e.g. kAxis)
   
   3. __init__(self: cscore.AxisCamera, name: llvm::StringRef, host: str) -> None
   
   Create a source for a MJPEG-over-HTTP (IP) camera.
   
   :param name: Source name (arbitrary unique identifier)
   :param urls: Array of Camera URLs
   :param kind: Camera kind (e.g. kAxis)
   
   4. __init__(self: cscore.AxisCamera, name: llvm::StringRef, host: llvm::ArrayRef<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >) -> None
   
   Create a source for a MJPEG-over-HTTP (IP) camera.
   
   :param name: Source name (arbitrary unique identifier)
   :param urls: Array of Camera URLs
   :param kind: Camera kind (e.g. kAxis)
   

CvSink
------

.. py:class:: CvSink(*args, **kwargs)
   :module: cscore

   Overloaded function.
   
   1. __init__(self: cscore.CvSink) -> None
   
   2. __init__(self: cscore.CvSink, name: llvm::StringRef) -> None
   
   Create a sink for accepting OpenCV images. :meth:`grabFrame` must be called on the created sink to get each new image
   
   :param name: Source name (arbitrary unique identifier)
   
   
   .. py:method:: CvSink.getError(self: cscore.CvSink) -> str
      :module: cscore
   
      Get error string.  Call this if :meth:`grabFrame` returns 0 to determine what the error is.
      
   
   .. py:method:: CvSink.grabFrame(self: cscore.CvSink, image: numpy.ndarray, timeout: float=0.225) -> Tuple[int, numpy.ndarray]
      :module: cscore
   
      Wait for the next frame and get the image. Times out (returning 0) after timeout seconds.
      The provided image will have three 8-bit channels stored in BGR order.
      
      :returns: Frame time, or 0 on error (call :meth:`getError` to obtain the error message), returned image
                The frame time is in 1us increments
      
   
   .. py:method:: CvSink.grabFrameNoTimeout(self: cscore.CvSink, image: numpy.ndarray) -> Tuple[int, numpy.ndarray]
      :module: cscore
   
      Wait for the next frame and get the image. May block forever.
      The provided image will have three 8-bit channels stored in BGR order.
      
      :returns: Frame time, or 0 on error (call :meth:`getError` to obtain the error message), returned image
                The frame time is in 1us increments
      
   
   .. py:method:: CvSink.setDescription(self: cscore.CvSink, description: llvm::StringRef) -> None
      :module: cscore
   
      Set sink description.
      
      :param description: Description
      
   
   .. py:method:: CvSink.setEnabled(self: cscore.CvSink, enabled: bool) -> None
      :module: cscore
   
      Enable or disable getting new frames.
      Disabling will cause processFrame (for callback-based CvSinks) to not be called and :meth:`grabFrame` to not return.  This can be used to save processor resources when frames are not needed.
      

CvSource
--------

.. py:class:: CvSource(*args, **kwargs)
   :module: cscore

   Overloaded function.
   
   1. __init__(self: cscore.CvSource) -> None
   
   2. __init__(self: cscore.CvSource, name: llvm::StringRef, mode: cscore.VideoMode) -> None
   
   Create an OpenCV source.
   
   :param name: Source name (arbitrary unique identifier)
   :param mode: Video mode being generated
   
   3. __init__(self: cscore.CvSource, name: llvm::StringRef, pixelFormat: cscore.PixelFormat, width: int, height: int, fps: int) -> None
   
   Create an OpenCV source.
   
   :param name: Source name (arbitrary unique identifier)
   :param pixelFormat: Pixel format
   :param width: width
   :param height: height
   :param fps: fps
   
   
   .. py:method:: CvSource.createBooleanProperty(self: cscore.CvSource, name: llvm::StringRef, defaultValue: bool, value: bool) -> cscore.VideoProperty
      :module: cscore
   
      Create a property.
      
      :param name: Property name
      :param defaultValue: Default value
      :param value: Current value
      
      :returns: Property
      
   
   .. py:method:: CvSource.createIntegerProperty(self: cscore.CvSource, name: llvm::StringRef, minimum: int, maximum: int, step: int, defaultValue: int, value: int) -> cscore.VideoProperty
      :module: cscore
   
      Create a property.
      
      :param name: Property name
      :param minimum: Minimum value
      :param maximum: Maximum value
      :param step: Step value
      :param defaultValue: Default value
      :param value: Current value
      
      :returns: Property
      
   
   .. py:method:: CvSource.createProperty(self: cscore.CvSource, name: llvm::StringRef, kind: cscore.Kind, minimum: int, maximum: int, step: int, defaultValue: int, value: int) -> cscore.VideoProperty
      :module: cscore
   
      Create a property.
      
      :param name: Property name
      :param kind: Property kind
      :param minimum: Minimum value
      :param maximum: Maximum value
      :param step: Step value
      :param defaultValue: Default value
      :param value: Current value
      
      :returns: Property
      
   
   .. py:method:: CvSource.createStringProperty(self: cscore.CvSource, name: llvm::StringRef, value: llvm::StringRef) -> cscore.VideoProperty
      :module: cscore
   
      Create a property.
      
      :param name: Property name
      :param value: Current value
      
      :returns: Property
      
   
   .. py:method:: CvSource.notifyError(self: cscore.CvSource, msg: llvm::StringRef) -> None
      :module: cscore
   
      Signal sinks that an error has occurred.  This should be called instead of :meth:`putFrame` when an error occurs.
      
   
   .. py:method:: CvSource.putFrame(self: cscore.CvSource, arg0: numpy.ndarray) -> None
      :module: cscore
   
      Put an OpenCV image and notify sinks.
      
      Only 8-bit single-channel or 3-channel (with BGR channel order) images are supported. If the format, depth or channel order is different, use ``cv2.convertTo()`` and/or ``cv2.cvtColor()`` to convert it first.
      
      :param image: OpenCV image
      
   
   .. py:method:: CvSource.setConnected(self: cscore.CvSource, connected: bool) -> None
      :module: cscore
   
      Set source connection status.  Defaults to true.
      
      :param connected: True for connected, false for disconnected
      
   
   .. py:method:: CvSource.setDescription(self: cscore.CvSource, description: llvm::StringRef) -> None
      :module: cscore
   
      Set source description.
      
      :param description: Description
      
   
   .. py:method:: CvSource.setEnumPropertyChoices(self: cscore.CvSource, property: cscore.VideoProperty, choices: llvm::ArrayRef<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >) -> None
      :module: cscore
   
      Configure enum property choices.
      
      :param property: Property
      :param choices: Choices
      

HttpCamera
----------

.. py:class:: HttpCamera(*args, **kwargs)
   :module: cscore

   Overloaded function.
   
   1. __init__(self: cscore.HttpCamera, name: llvm::StringRef, url: str, kind: cscore.HttpCameraKind=HttpCameraKind.kUnknown) -> None
   
   Create a source for a MJPEG-over-HTTP (IP) camera.
   
   :param name: Source name (arbitrary unique identifier)
   :param urls: Array of Camera URLs
   :param kind: Camera kind (e.g. kAxis)
   
   2. __init__(self: cscore.HttpCamera, name: llvm::StringRef, urls: llvm::ArrayRef<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, kind: cscore.HttpCameraKind=HttpCameraKind.kUnknown) -> None
   
   Create a source for a MJPEG-over-HTTP (IP) camera.
   
   :param name: Source name (arbitrary unique identifier)
   :param urls: Array of Camera URLs
   :param kind: Camera kind (e.g. kAxis)
   
   
   .. py:class:: HttpCamera.HttpCameraKind(self: cscore.HttpCameraKind, arg0: int) -> None
      :module: cscore
   
      
      .. py:attribute:: HttpCamera.HttpCameraKind.kAxis
         :module: cscore
         :annotation: = HttpCameraKind.kAxis
      
      
      .. py:attribute:: HttpCamera.HttpCameraKind.kCSCore
         :module: cscore
         :annotation: = HttpCameraKind.kCSCore
      
      
      .. py:attribute:: HttpCamera.HttpCameraKind.kMJPGStreamer
         :module: cscore
         :annotation: = HttpCameraKind.kMJPGStreamer
      
      
      .. py:attribute:: HttpCamera.HttpCameraKind.kUnknown
         :module: cscore
         :annotation: = HttpCameraKind.kUnknown
      
   
   .. py:method:: HttpCamera.getHttpCameraKind(self: cscore.HttpCamera) -> cscore.HttpCameraKind
      :module: cscore
   
      Get the kind of HTTP camera. Autodetection can result in returning a different value than the camera was created with.
      
   
   .. py:method:: HttpCamera.getUrls(self: cscore.HttpCamera) -> List[str]
      :module: cscore
   
      Get the URLs used to connect to the camera.
      
   
   .. py:method:: HttpCamera.setUrls(self: cscore.HttpCamera, urls: llvm::ArrayRef<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >) -> None
      :module: cscore
   
      Change the URLs used to connect to the camera.
      

MjpegServer
-----------

.. py:class:: MjpegServer(*args, **kwargs)
   :module: cscore

   Overloaded function.
   
   1. __init__(self: cscore.MjpegServer) -> None
   
   2. __init__(self: cscore.MjpegServer, name: llvm::StringRef, listenAddress: llvm::StringRef, port: int) -> None
   
   Create a MJPEG-over-HTTP server sink.
   
   :param name: Sink name (arbitrary unique identifier)
   :param listenAddress: TCP listen address (empty string for all addresses)
   :param port: TCP port number
   
   3. __init__(self: cscore.MjpegServer, name: llvm::StringRef, port: int) -> None
   
   Create a MJPEG-over-HTTP server sink.
   
   :param name: Sink name (arbitrary unique identifier)
   :param port: TCP port number
   
   
   .. py:method:: MjpegServer.getListenAddress(self: cscore.MjpegServer) -> str
      :module: cscore
   
      Get the listen address of the server.
      
   
   .. py:method:: MjpegServer.getPort(self: cscore.MjpegServer) -> int
      :module: cscore
   
      Get the port number of the server.
      

RawEvent
--------

.. py:class:: RawEvent
   :module: cscore

   
   .. py:class:: RawEvent.Kind(self: cscore.Kind, arg0: int) -> None
      :module: cscore
   
      
      .. py:attribute:: RawEvent.Kind.kNetworkInterfacesChanged
         :module: cscore
         :annotation: = Kind.kNetworkInterfacesChanged
      
      
      .. py:attribute:: RawEvent.Kind.kSinkCreated
         :module: cscore
         :annotation: = Kind.kSinkCreated
      
      
      .. py:attribute:: RawEvent.Kind.kSinkDestroyed
         :module: cscore
         :annotation: = Kind.kSinkDestroyed
      
      
      .. py:attribute:: RawEvent.Kind.kSinkDisabled
         :module: cscore
         :annotation: = Kind.kSinkDisabled
      
      
      .. py:attribute:: RawEvent.Kind.kSinkEnabled
         :module: cscore
         :annotation: = Kind.kSinkEnabled
      
      
      .. py:attribute:: RawEvent.Kind.kSinkSourceChanged
         :module: cscore
         :annotation: = Kind.kSinkSourceChanged
      
      
      .. py:attribute:: RawEvent.Kind.kSourceConnected
         :module: cscore
         :annotation: = Kind.kSourceConnected
      
      
      .. py:attribute:: RawEvent.Kind.kSourceCreated
         :module: cscore
         :annotation: = Kind.kSourceCreated
      
      
      .. py:attribute:: RawEvent.Kind.kSourceDestroyed
         :module: cscore
         :annotation: = Kind.kSourceDestroyed
      
      
      .. py:attribute:: RawEvent.Kind.kSourceDisconnected
         :module: cscore
         :annotation: = Kind.kSourceDisconnected
      
      
      .. py:attribute:: RawEvent.Kind.kSourcePropertyChoicesUpdated
         :module: cscore
         :annotation: = Kind.kSourcePropertyChoicesUpdated
      
      
      .. py:attribute:: RawEvent.Kind.kSourcePropertyCreated
         :module: cscore
         :annotation: = Kind.kSourcePropertyCreated
      
      
      .. py:attribute:: RawEvent.Kind.kSourcePropertyValueUpdated
         :module: cscore
         :annotation: = Kind.kSourcePropertyValueUpdated
      
      
      .. py:attribute:: RawEvent.Kind.kSourceVideoModeChanged
         :module: cscore
         :annotation: = Kind.kSourceVideoModeChanged
      
      
      .. py:attribute:: RawEvent.Kind.kSourceVideoModesUpdated
         :module: cscore
         :annotation: = Kind.kSourceVideoModesUpdated
      
   
   .. py:attribute:: RawEvent.kind
      :module: cscore
   
   
   .. py:attribute:: RawEvent.mode
      :module: cscore
   
   
   .. py:attribute:: RawEvent.name
      :module: cscore
   
   
   .. py:attribute:: RawEvent.sinkHandle
      :module: cscore
   
   
   .. py:attribute:: RawEvent.sourceHandle
      :module: cscore
   
   
   .. py:attribute:: RawEvent.value
      :module: cscore
   
   
   .. py:attribute:: RawEvent.valueStr
      :module: cscore
   

UsbCamera
---------

.. py:class:: UsbCamera(*args, **kwargs)
   :module: cscore

   Overloaded function.
   
   1. __init__(self: cscore.UsbCamera) -> None
   
   2. __init__(self: cscore.UsbCamera, name: llvm::StringRef, dev: int) -> None
   
   Create a source for a USB camera based on device number.
   
   :param name: Source name (arbitrary unique identifier)
   :param dev: Device number (e.g. 0 for ``/dev/video0``)
   
   3. __init__(self: cscore.UsbCamera, name: llvm::StringRef, path: llvm::StringRef) -> None
   
   Create a source for a USB camera based on device path.
   
   :param name: Source name (arbitrary unique identifier)
   :param path: Path to device (e.g. ``/dev/video0`` on Linux)
   
   
   .. py:method:: UsbCamera.enumerateUsbCameras() -> List[cscore.UsbCameraInfo]
      :module: cscore
   
      Enumerate USB cameras on the local system.
      
      :returns: list of USB camera information (one for each camera)
      
   
   .. py:method:: UsbCamera.getPath(self: cscore.UsbCamera) -> str
      :module: cscore
   
      Get the path to the device.
      

UsbCameraInfo
-------------

.. py:class:: UsbCameraInfo
   :module: cscore

   
   .. py:attribute:: UsbCameraInfo.dev
      :module: cscore
   
   
   .. py:attribute:: UsbCameraInfo.name
      :module: cscore
   
   
   .. py:attribute:: UsbCameraInfo.path
      :module: cscore
   

VideoCamera
-----------

.. py:class:: VideoCamera(self: cscore.VideoCamera) -> None
   :module: cscore

   
   .. py:class:: VideoCamera.WhiteBalance(self: cscore.WhiteBalance, arg0: int) -> None
      :module: cscore
   
      
      .. py:attribute:: VideoCamera.WhiteBalance.kFixedFlourescent2
         :module: cscore
         :annotation: = WhiteBalance.kFixedFlourescent2
      
      
      .. py:attribute:: VideoCamera.WhiteBalance.kFixedFluorescent1
         :module: cscore
         :annotation: = WhiteBalance.kFixedFluorescent1
      
      
      .. py:attribute:: VideoCamera.WhiteBalance.kFixedIndoor
         :module: cscore
         :annotation: = WhiteBalance.kFixedIndoor
      
      
      .. py:attribute:: VideoCamera.WhiteBalance.kFixedOutdoor1
         :module: cscore
         :annotation: = WhiteBalance.kFixedOutdoor1
      
      
      .. py:attribute:: VideoCamera.WhiteBalance.kFixedOutdoor2
         :module: cscore
         :annotation: = WhiteBalance.kFixedOutdoor2
      
   
   .. py:method:: VideoCamera.getBrightness(self: cscore.VideoCamera) -> int
      :module: cscore
   
      Get the brightness, as a percentage (0-100).
      
   
   .. py:method:: VideoCamera.setBrightness(self: cscore.VideoCamera, brightness: int) -> None
      :module: cscore
   
      Set the brightness, as a percentage (0-100).
      
   
   .. py:method:: VideoCamera.setExposureAuto(self: cscore.VideoCamera) -> None
      :module: cscore
   
      Set the exposure to auto aperature.
      
   
   .. py:method:: VideoCamera.setExposureHoldCurrent(self: cscore.VideoCamera) -> None
      :module: cscore
   
      Set the exposure to hold current.
      
   
   .. py:method:: VideoCamera.setExposureManual(self: cscore.VideoCamera, value: int) -> None
      :module: cscore
   
      Set the exposure to manual, as a percentage (0-100).
      
   
   .. py:method:: VideoCamera.setWhiteBalanceAuto(self: cscore.VideoCamera) -> None
      :module: cscore
   
      Set the white balance to auto.
      
   
   .. py:method:: VideoCamera.setWhiteBalanceHoldCurrent(self: cscore.VideoCamera) -> None
      :module: cscore
   
      Set the white balance to hold current.
      
   
   .. py:method:: VideoCamera.setWhiteBalanceManual(self: cscore.VideoCamera, value: int) -> None
      :module: cscore
   
      Set the white balance to manual, with specified color temperature.
      

VideoEvent
----------

.. py:class:: VideoEvent
   :module: cscore

   
   .. py:method:: VideoEvent.getProperty(self: cscore.VideoEvent) -> cscore.VideoProperty
      :module: cscore
   
   
   .. py:method:: VideoEvent.getSink(self: cscore.VideoEvent) -> cscore.VideoSink
      :module: cscore
   
   
   .. py:method:: VideoEvent.getSource(self: cscore.VideoEvent) -> cscore.VideoSource
      :module: cscore
   

VideoListener
-------------

.. py:class:: VideoListener(self: cscore.VideoListener, callback: Callable[[cscore.VideoEvent], None], eventMask: int, immediateNotify: bool) -> None
   :module: cscore

   Create an event listener.
   
   :param callback: Callback function
   :param eventMask: Bitmask of VideoEvent.Kind values
   :param immediateNotify: Whether callback should be immediately called with a representative set of events for the current library state.
   

VideoMode
---------

.. py:class:: VideoMode(*args, **kwargs)
   :module: cscore

   Overloaded function.
   
   1. __init__(self: cscore.VideoMode) -> None
   
   2. __init__(self: cscore.VideoMode, arg0: cs::VideoMode::PixelFormat, arg1: int, arg2: int, arg3: int) -> None
   
   
   .. py:class:: VideoMode.PixelFormat(self: cscore.PixelFormat, arg0: int) -> None
      :module: cscore
   
      
      .. py:attribute:: VideoMode.PixelFormat.kBGR
         :module: cscore
         :annotation: = PixelFormat.kBGR
      
      
      .. py:attribute:: VideoMode.PixelFormat.kGray
         :module: cscore
         :annotation: = PixelFormat.kGray
      
      
      .. py:attribute:: VideoMode.PixelFormat.kMJPEG
         :module: cscore
         :annotation: = PixelFormat.kMJPEG
      
      
      .. py:attribute:: VideoMode.PixelFormat.kRGB565
         :module: cscore
         :annotation: = PixelFormat.kRGB565
      
      
      .. py:attribute:: VideoMode.PixelFormat.kUnknown
         :module: cscore
         :annotation: = PixelFormat.kUnknown
      
      
      .. py:attribute:: VideoMode.PixelFormat.kYUYV
         :module: cscore
         :annotation: = PixelFormat.kYUYV
      
   
   .. py:attribute:: VideoMode.fps
      :module: cscore
   
   
   .. py:attribute:: VideoMode.height
      :module: cscore
   
   
   .. py:attribute:: VideoMode.pixelFormat
      :module: cscore
   
   
   .. py:attribute:: VideoMode.width
      :module: cscore
   

VideoProperty
-------------

.. py:class:: VideoProperty(self: cscore.VideoProperty) -> None
   :module: cscore

   
   .. py:class:: VideoProperty.Kind(self: cscore.Kind, arg0: int) -> None
      :module: cscore
   
      
      .. py:attribute:: VideoProperty.Kind.kBoolean
         :module: cscore
         :annotation: = Kind.kBoolean
      
      
      .. py:attribute:: VideoProperty.Kind.kEnum
         :module: cscore
         :annotation: = Kind.kEnum
      
      
      .. py:attribute:: VideoProperty.Kind.kInteger
         :module: cscore
         :annotation: = Kind.kInteger
      
      
      .. py:attribute:: VideoProperty.Kind.kNone
         :module: cscore
         :annotation: = Kind.kNone
      
      
      .. py:attribute:: VideoProperty.Kind.kString
         :module: cscore
         :annotation: = Kind.kString
      
   
   .. py:method:: VideoProperty.get(self: cscore.VideoProperty) -> int
      :module: cscore
   
   
   .. py:method:: VideoProperty.getChoices(self: cscore.VideoProperty) -> List[str]
      :module: cscore
   
   
   .. py:method:: VideoProperty.getDefault(self: cscore.VideoProperty) -> int
      :module: cscore
   
   
   .. py:method:: VideoProperty.getKind(self: cscore.VideoProperty) -> cs::VideoProperty::Kind
      :module: cscore
   
   
   .. py:method:: VideoProperty.getLastStatus(self: cscore.VideoProperty) -> int
      :module: cscore
   
   
   .. py:method:: VideoProperty.getMax(self: cscore.VideoProperty) -> int
      :module: cscore
   
   
   .. py:method:: VideoProperty.getMin(self: cscore.VideoProperty) -> int
      :module: cscore
   
   
   .. py:method:: VideoProperty.getName(self: cscore.VideoProperty) -> str
      :module: cscore
   
   
   .. py:method:: VideoProperty.getStep(self: cscore.VideoProperty) -> int
      :module: cscore
   
   
   .. py:method:: VideoProperty.getString(self: cscore.VideoProperty) -> str
      :module: cscore
   
   
   .. py:method:: VideoProperty.isBoolean(self: cscore.VideoProperty) -> bool
      :module: cscore
   
   
   .. py:method:: VideoProperty.isEnum(self: cscore.VideoProperty) -> bool
      :module: cscore
   
   
   .. py:method:: VideoProperty.isInteger(self: cscore.VideoProperty) -> bool
      :module: cscore
   
   
   .. py:method:: VideoProperty.isString(self: cscore.VideoProperty) -> bool
      :module: cscore
   
   
   .. py:method:: VideoProperty.set(self: cscore.VideoProperty, value: int) -> None
      :module: cscore
   
   
   .. py:method:: VideoProperty.setString(self: cscore.VideoProperty, value: llvm::StringRef) -> None
      :module: cscore
   

VideoSink
---------

.. py:class:: VideoSink(*args, **kwargs)
   :module: cscore

   Overloaded function.
   
   1. __init__(self: cscore.VideoSink) -> None
   
   2. __init__(self: cscore.VideoSink, sink: cscore.VideoSink) -> None
   
   
   .. py:class:: VideoSink.Kind(self: cscore.Kind, arg0: int) -> None
      :module: cscore
   
      
      .. py:attribute:: VideoSink.Kind.kCv
         :module: cscore
         :annotation: = Kind.kCv
      
      
      .. py:attribute:: VideoSink.Kind.kMjpeg
         :module: cscore
         :annotation: = Kind.kMjpeg
      
      
      .. py:attribute:: VideoSink.Kind.kUnknown
         :module: cscore
         :annotation: = Kind.kUnknown
      
   
   .. py:method:: VideoSink.enumerateSinks() -> List[cscore.VideoSink]
      :module: cscore
   
      Enumerate all existing sinks.
      
      :returns: list of sinks.
      
   
   .. py:method:: VideoSink.getDescription(self: cscore.VideoSink) -> str
      :module: cscore
   
      Get the sink description.  This is sink-kind specific.
      
   
   .. py:method:: VideoSink.getHandle(self: cscore.VideoSink) -> int
      :module: cscore
   
   
   .. py:method:: VideoSink.getKind(self: cscore.VideoSink) -> cs::VideoSink::Kind
      :module: cscore
   
      Get the kind of the sink.
      
   
   .. py:method:: VideoSink.getLastStatus(self: cscore.VideoSink) -> int
      :module: cscore
   
   
   .. py:method:: VideoSink.getName(self: cscore.VideoSink) -> str
      :module: cscore
   
      Get the name of the sink.  The name is an arbitrary identifier provided when the sink is created, and should be unique.
      
   
   .. py:method:: VideoSink.getSource(self: cscore.VideoSink) -> cscore.VideoSource
      :module: cscore
   
      Get the connected source.
      
      :returns: Connected source (empty if none connected).
      
   
   .. py:method:: VideoSink.getSourceProperty(self: cscore.VideoSink, arg0: llvm::StringRef) -> cscore.VideoProperty
      :module: cscore
   
      Get a property of the associated source.
      
      :param name: Property name
      :returns: Property (VideoSink.Kind.kNone if no property with the given name exists or no source connected)
      
   
   .. py:method:: VideoSink.setSource(self: cscore.VideoSink, source: cscore.VideoSource) -> None
      :module: cscore
   
      Configure which source should provide frames to this sink.  Each sink can accept frames from only a single source, but a single source can provide frames to multiple clients.
      
      :param source: Source
      

VideoSource
-----------

.. py:class:: VideoSource(*args, **kwargs)
   :module: cscore

   Overloaded function.
   
   1. __init__(self: cscore.VideoSource) -> None
   
   2. __init__(self: cscore.VideoSource, source: cscore.VideoSource) -> None
   
   
   .. py:class:: VideoSource.Kind(self: cscore.Kind, arg0: int) -> None
      :module: cscore
   
      
      .. py:attribute:: VideoSource.Kind.kCv
         :module: cscore
         :annotation: = Kind.kCv
      
      
      .. py:attribute:: VideoSource.Kind.kHttp
         :module: cscore
         :annotation: = Kind.kHttp
      
      
      .. py:attribute:: VideoSource.Kind.kUnknown
         :module: cscore
         :annotation: = Kind.kUnknown
      
      
      .. py:attribute:: VideoSource.Kind.kUsb
         :module: cscore
         :annotation: = Kind.kUsb
      
   
   .. py:method:: VideoSource.enumerateProperties(self: cscore.VideoSource) -> List[cscore.VideoProperty]
      :module: cscore
   
      Enumerate all properties of this source
      
   
   .. py:method:: VideoSource.enumerateSinks(self: cscore.VideoSource) -> List[cs::VideoSink]
      :module: cscore
   
      Enumerate all sinks connected to this source.
      
      :returns: list of sinks.
      
   
   .. py:method:: VideoSource.enumerateSources() -> List[cscore.VideoSource]
      :module: cscore
   
      Enumerate all existing sources.
      
      :returns: list of sources.
      
   
   .. py:method:: VideoSource.enumerateVideoModes(self: cscore.VideoSource) -> List[cscore.VideoMode]
      :module: cscore
   
      Enumerate all known video modes for this source.
      
   
   .. py:method:: VideoSource.getDescription(self: cscore.VideoSource) -> str
      :module: cscore
   
      Get the source description.  This is source-kind specific.
      
   
   .. py:method:: VideoSource.getHandle(self: cscore.VideoSource) -> int
      :module: cscore
   
   
   .. py:method:: VideoSource.getKind(self: cscore.VideoSource) -> cs::VideoSource::Kind
      :module: cscore
   
      Get the kind of the source
      
   
   .. py:method:: VideoSource.getLastFrameTime(self: cscore.VideoSource) -> int
      :module: cscore
   
      Get the last time a frame was captured.
      
   
   .. py:method:: VideoSource.getLastStatus(self: cscore.VideoSource) -> int
      :module: cscore
   
   
   .. py:method:: VideoSource.getName(self: cscore.VideoSource) -> str
      :module: cscore
   
      Get the name of the source. The name is an arbitrary identifier provided when the source is created, and should be unique.
      
   
   .. py:method:: VideoSource.getProperty(self: cscore.VideoSource, name: llvm::StringRef) -> cscore.VideoProperty
      :module: cscore
   
      Get a property.
      
      :param name: Property name
      :returns: Property contents (VideoSource.Kind.kNone if no property with the given name exists)
      
   
   .. py:method:: VideoSource.getVideoMode(self: cscore.VideoSource) -> cscore.VideoMode
      :module: cscore
   
      Get the current video mode.
      
   
   .. py:method:: VideoSource.isConnected(self: cscore.VideoSource) -> bool
      :module: cscore
   
      Is the source currently connected to whatever is providing the images?
      
   
   .. py:method:: VideoSource.setFPS(self: cscore.VideoSource, fps: int) -> bool
      :module: cscore
   
      Set the frames per second (FPS).
      
      :param fps: desired FPS
      :returns: True if set successfully
      
   
   .. py:method:: VideoSource.setPixelFormat(self: cscore.VideoSource, pixelFormat: cscore.PixelFormat) -> bool
      :module: cscore
   
      Set the pixel format.
      
      :param pixelFormat: desired pixel format
      :returns: True if set successfully
      
   
   .. py:method:: VideoSource.setResolution(self: cscore.VideoSource, width: int, height: int) -> bool
      :module: cscore
   
      Set the resolution.
      
      :param width: desired width
      :param height: desired height
      :returns: True if set successfully
      
   
   .. py:method:: VideoSource.setVideoMode(*args, **kwargs)
      :module: cscore
   
      Overloaded function.
      
      1. setVideoMode(self: cscore.VideoSource, mode: cscore.VideoMode) -> bool
      
      Set the video mode.
      
      :param mode: Video mode
      
      2. setVideoMode(self: cscore.VideoSource, pixelFormat: cscore.PixelFormat, width: int, height: int, fps: int) -> bool
      
      Set the video mode.
      
      :param pixelFormat: desired pixel format
      :param width: desired width
      :param height: desired height
      :param fps: desired FPS
      :returns: True if set successfully
      

.. py:function:: getHttpCameraUrls(arg0: int) -> List[str]
   :module: cscore


.. py:function:: getMjpegServerListenAddress(arg0: int, arg1: int) -> str
   :module: cscore


.. py:function:: getMjpegServerPort(arg0: int) -> List[str]
   :module: cscore


.. py:function:: getNetworkInterfaces() -> List[str]
   :module: cscore


.. py:function:: getUsbCameraPath(arg0: int) -> str
   :module: cscore


.. py:function:: setLogger(arg0: Callable[[int, str, int, str], None], arg1: int) -> None
   :module: cscore

